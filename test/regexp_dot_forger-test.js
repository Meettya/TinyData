// Generated by CoffeeScript 1.4.0

/*
Test suite for node AND browser in one file
So, we are need some data from global
Its so wrong, but its OK for test
*/


(function() {
  var RegExpDotForger, character_set_pattern, character_set_pattern_suite, dot_substitutor, escaped_dot_pattern, escaped_dot_pattern_suite, forger_obj, lib_path, substitution_test_suite, _, _ref;

  _ = (_ref = this._) != null ? _ref : require('lodash');

  lib_path = (typeof GLOBAL !== "undefined" && GLOBAL !== null ? GLOBAL.lib_path : void 0) || '';

  RegExpDotForger = require("" + lib_path + "lib/regexp_dot_forger");

  forger_obj = character_set_pattern = escaped_dot_pattern = null;

  dot_substitutor = "\uFE45";

  character_set_pattern_suite = {
    example_true: [/[]/, /[.]/, /[[.]/, /[.[]/, /[\]\.\[]/, /\\[\.]/, /\\\\[.\\\\]\\/, /[.\\]/, /dtt[.]/, /3434\\[\\.]\/\//, /^\.rtt([^.]+)\./, /^[^.]+\.comment\.([^.]+)\./],
    example_false: [/\[.]/, /\\\[.\.]/, /ddsds\[.]/]
  };

  escaped_dot_pattern_suite = {
    example_true: [/\./, /\\\./, /^\d+[.\]]ft\./, /\\\\\.\\\.\./],
    example_false: [/\\./, /sd\b\\\\./, /\(.\)/]
  };

  substitution_test_suite = {
    example_true: [[/\./, /\uFE45/], [/[.]/, /[\uFE45]/], [/[\.]/, /[\\uFE45]/], [/[...]/, /[\uFE45\uFE45\uFE45]/], [/^[^.]+\.comment\.([^.]+)\./, /^[^﹅]+﹅comment﹅([^﹅]+)﹅/]],
    example_false: [[/\\./, /\\./], [/\[.]/, /\[.]/]]
  };

  describe('RegExpDotForger:', function() {
    beforeEach(function() {
      return forger_obj = new RegExpDotForger(dot_substitutor);
    });
    describe('new()', function() {
      it('should return RegExpDotForger object on call with data', function() {
        forger_obj = new RegExpDotForger(dot_substitutor);
        return forger_obj.should.be.an["instanceof"](RegExpDotForger);
      });
      return it('should throw Error on void call', function() {
        return (function() {
          return new RegExpDotForger();
        }).should.to["throw"](/constructor must be called with/);
      });
    });
    describe('#getPatternByName()', function() {
      it('should return existance pattern', function() {
        character_set_pattern = forger_obj.getPatternByName('character_set');
        return character_set_pattern.should.to.be["instanceof"](RegExp);
      });
      return it('should throw Error on unknown name', function() {
        return (function() {
          return forger_obj.getPatternByName('foo_bar');
        }).should.to["throw"](/don`t know pattern/);
      });
    });
    describe('#doForgeDots()', function() {
      it('should change escaped dots (\\.) and dots in character set ([.]) to substitutor', function() {
        return _.each(substitution_test_suite.example_true, function(test_suite) {
          return forger_obj.doForgeDots(test_suite[0]).should.be.eql(test_suite[1]);
        });
      });
      return it('should NOT change dots itself as "one symbol" (.) to substitutor', function() {
        return _.each(substitution_test_suite.example_false, function(test_suite) {
          return forger_obj.doForgeDots(test_suite[0]).should.be.eql(test_suite[1]);
        });
      });
    });
    return describe('patterns ITSELF for searching in regexp patterns:', function() {
      describe('\'character set\' search pattern:', function() {
        beforeEach(function() {
          return character_set_pattern = forger_obj.getPatternByName('character_set');
        });
        it('should match righ things', function() {
          return _.each(character_set_pattern_suite.example_true, function(pattern) {
            return character_set_pattern.test(pattern.source).should.to.be["true"];
          });
        });
        return it('should NOT match wrong things', function() {
          return _.each(character_set_pattern_suite.example_false, function(pattern) {
            return character_set_pattern.test(pattern.source).should.to.be["false"];
          });
        });
      });
      return describe('\'escaped dot\' search pattern:', function() {
        beforeEach(function() {
          return escaped_dot_pattern = forger_obj.getPatternByName('escaped_dot');
        });
        it('should match righ things', function() {
          return _.each(escaped_dot_pattern_suite.example_true, function(pattern) {
            return escaped_dot_pattern.test(pattern.source).should.to.be["true"];
          });
        });
        return it('should NOT match wrong things', function() {
          return _.each(escaped_dot_pattern_suite.example_false, function(pattern) {
            return escaped_dot_pattern.test(pattern.source).should.to.be["false"];
          });
        });
      });
    });
  });

}).call(this);
