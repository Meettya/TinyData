// Generated by CoffeeScript 1.4.0

/*
This is Stringificator for TinyData

Its get object and return materialized path, with some changes, like:
  * filter some data
  * cut long text values
  * change data values to stub (not realized)
*/


(function() {
  var Stringificator, getItType, _;

  _ = require('lodash');

  getItType = require("./type_detector").getItType;

  Stringificator = (function() {

    function Stringificator(_original_obj_, _internal_path_delimiter_, _regexp_transformation_fn_, _options_) {
      this._original_obj_ = _original_obj_;
      this._internal_path_delimiter_ = _internal_path_delimiter_;
      this._regexp_transformation_fn_ = _regexp_transformation_fn_;
      this._options_ = _options_ != null ? _options_ : {};
      this._cache_stringifyed_object_ = null;
      this._stringification_rule = {
        stubs_list: [],
        stringify_filter: null
      };
      this._max_text_long_ = 120;
      this._convert_stringify_filter = true;
      this._do_logging_ = (this._options_.log != null) && this._options_.log === true && ((typeof console !== "undefined" && console !== null ? console.log : void 0) != null) ? true : false;
    }

    /*
      This is public method, wrapper for internal and realize a cache
    */


    Stringificator.prototype.stringifyObject = function(in_stringify_filter, in_stubs_list) {
      var stringify_stub_list, stringy_filter, _ref;
      stringy_filter = this._stringification_rule.stringify_filter;
      stringify_stub_list = this._stringification_rule.stubs_list;
      in_stringify_filter || (in_stringify_filter = stringy_filter);
      in_stubs_list || (in_stubs_list = stringify_stub_list);
      if (!(this._cache_stringifyed_object_ != null) || !_.isEqual(in_stringify_filter, stringy_filter) || !_.isEqual(in_stubs_list, stringify_stub_list)) {
        if (this._do_logging_) {
          console.log('stringify cache miss');
        }
        _ref = [in_stringify_filter, in_stubs_list], stringy_filter = _ref[0], stringify_stub_list = _ref[1];
        return this._cache_stringifyed_object_ = this._doStringification(in_stringify_filter, in_stubs_list);
      } else {
        if (this._do_logging_) {
          console.log('stringify cache hit');
        }
        return this._cache_stringifyed_object_;
      }
    };

    /*
      This method stringify object
    */


    Stringificator.prototype._doStringification = function(stringify_rule, stubs_list) {
      var dot_sign, filter_body, innner_loop, is_filter_passed, result_array, string_limiter,
        _this = this;
      filter_body = this._makeElementFilter(stringify_rule);
      string_limiter = this._makeStringLimiter(this._max_text_long_);
      is_filter_passed = stringify_rule != null ? filter_body : function() {
        return true;
      };
      dot_sign = this._internal_path_delimiter_;
      result_array = [];
      innner_loop = function(in_obj, prefix, depth) {
        var idx, in_obj_type, key, obj_keys, value, _i, _j, _len, _len1;
        switch (in_obj_type = getItType(in_obj)) {
          case 'HASH':
            obj_keys = _.keys(in_obj);
            if (obj_keys.length) {
              for (_i = 0, _len = obj_keys.length; _i < _len; _i++) {
                key = obj_keys[_i];
                if (is_filter_passed(prefix, key, depth)) {
                  innner_loop(in_obj[key], "" + prefix + key + dot_sign, depth + 1);
                }
              }
            } else {
              innner_loop("__EMPTY__|HASH|", "" + prefix, depth);
            }
            break;
          case 'ARRAY':
            if (in_obj.length) {
              for (idx = _j = 0, _len1 = in_obj.length; _j < _len1; idx = ++_j) {
                value = in_obj[idx];
                if (is_filter_passed(prefix, idx, depth)) {
                  innner_loop(value, "" + prefix + idx + dot_sign, depth + 1);
                }
              }
            } else {
              innner_loop("__EMPTY__|ARRAY|", "" + prefix, depth);
            }
            break;
          case 'NUMBER':
          case 'BOOLEAN':
          case 'NULL':
            result_array.push("" + prefix + in_obj);
            break;
          case 'STRING':
            result_array.push(string_limiter(prefix, in_obj, depth));
            break;
          case 'DATE':
          case 'REGEXP':
            result_array.push("" + prefix + "__" + in_obj_type + "__|" + in_obj + "|__");
            break;
          default:
            result_array.push("" + prefix + "__" + in_obj_type + "__");
        }
        return null;
      };
      innner_loop(this._original_obj_, '', 0);
      return result_array;
    };

    /*
      This method create limiter for long text
    */


    Stringificator.prototype._makeStringLimiter = function(max_length) {
      var _this = this;
      return function(full_elem_path, elem_content, elem_depth) {
        var elem_length;
        elem_length = elem_content.length;
        if (!(elem_length > max_length)) {
          return "" + full_elem_path + elem_content;
        } else {
          return "" + full_elem_path + "__LONG_TEXT__|" + elem_length + "|";
        }
      };
    };

    /*
      This method create stringify filter
      to reduce part of values to speed up stringification and seeking
    */


    Stringificator.prototype._makeElementFilter = function(stringify_rule) {
      var name_matcher, stringify_pattern,
        _this = this;
      name_matcher = (stringify_rule != null ? stringify_rule.origin_pattern : void 0) != null ? (stringify_pattern = stringify_rule.origin_pattern, this._convert_stringify_filter ? stringify_pattern = this._regexp_transformation_fn_(stringify_pattern) : void 0, function(matcher_elem_name, matcher_elem_origin) {
        return matcher_elem_name === stringify_rule.element_name && stringify_pattern.test(matcher_elem_origin);
      }) : function(matcher_elem_name) {
        return matcher_elem_name === stringify_rule.element_name;
      };
      return function(elem_origin, elem_name, elem_depth) {
        if (stringify_rule.apply_on_depth === elem_depth) {
          return name_matcher(elem_name, elem_origin);
        } else {
          return true;
        }
      };
    };

    return Stringificator;

  })();

  module.exports = Stringificator;

}).call(this);
