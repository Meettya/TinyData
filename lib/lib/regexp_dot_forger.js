// Generated by CoffeeScript 1.4.0

/*
This is RegExp helper for TinyData

Its convert users RegExp with escaped dot \.
 or dot as a part of character set [.] - like this,
 by replace all of that to something else 

Raison d'Ãªtre - inside TinyData for entity devision used dot_replacer,
  but for the simplicity we are MAY (and I believe MUST) cloak this fact.
*/


/*
Logging method decorator
*/


(function() {
  var RegExpDotForger, logOnDemand, _, _ref,
    __slice = [].slice;

  logOnDemand = function(methodBody) {
    return function() {
      var args, __rval__;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      __rval__ = methodBody.apply(this, args);
      if (this._do_logging_) {
        console.log("" + args[0] + " -> " + __rval__);
      }
      return __rval__;
    };
  };

  _ = (_ref = this._) != null ? _ref : require('lodash');

  RegExpDotForger = (function() {

    function RegExpDotForger(_dot_substitute_, _options_) {
      this._dot_substitute_ = _dot_substitute_;
      this._options_ = _options_ != null ? _options_ : {};
      if (!((this._dot_substitute_ != null) && _.isString(this._dot_substitute_))) {
        throw Error("constructor must be called with string as dot substitute, but got:\n|dot_substitute| = |" + this._dot_substitute_ + "|");
      }
      this._do_logging_ = (this._options_.log != null) && this._options_.log === true && ((typeof console !== "undefined" && console !== null ? console.log : void 0) != null) ? true : false;
    }

    /*
      This method return pattern RegExp by name or throw exception
      why it public? for tests
    */


    RegExpDotForger.prototype.getPatternByName = function(pattern_name) {
      switch (pattern_name.toUpperCase()) {
        case 'CHARACTER_SET':
          return /((?:^|(?:(?:^|[^\\])\\(?:\\{2})*\\)|[^\\]+))(\[(?:]|(?:[^\\]+])|(?:.*?[^\\]+])|(?:.*?[^\\]+\\(?:\\{2})*\\])))/;
        case 'ESCAPED_DOT':
          return /((?:^|[^\\])(?:\\{2})*)(\\\.)/;
        default:
          throw Error("so far don`t know pattern, named |" + pattern_name + "|, mistype?");
      }
    };

    /*
      This method forge dots in incoming regexp and return 'corrected' one
    */


    RegExpDotForger.prototype.doForgeDots = logOnDemand(function(in_regexp) {
      if (!((in_regexp != null) && _.isRegExp(in_regexp))) {
        throw Error("must be called with RegExp, but got:\n|in_regexp| = |" + in_regexp + "|");
      }
      return new RegExp(this._forgeEscapedDots(this._forgeCharacterSet(in_regexp.source)));
    });

    /*
      This method change dots to substitute in character sets
    */


    RegExpDotForger.prototype._forgeCharacterSet = function(in_regexp_as_string) {
      var dot_replacer, global_char_set_pattern,
        _this = this;
      global_char_set_pattern = new RegExp(this.getPatternByName('character_set').source, 'g');
      dot_replacer = function(match, captured_1, captured_2) {
        var forged_set;
        forged_set = captured_2.replace(/\./g, _this._dot_substitute_);
        return captured_1 + forged_set;
      };
      return in_regexp_as_string.replace(global_char_set_pattern, dot_replacer);
    };

    /*
      This method change escaped dots to substitute
    */


    RegExpDotForger.prototype._forgeEscapedDots = function(in_regexp_as_string) {
      var escaped_dot_replacer, global_escaped_dot_pattern,
        _this = this;
      global_escaped_dot_pattern = new RegExp(this.getPatternByName('escaped_dot').source, 'g');
      escaped_dot_replacer = function(match, captured_1, captured_2) {
        var forged_set;
        forged_set = captured_2.replace(/\\\./, _this._dot_substitute_);
        return captured_1 + forged_set;
      };
      return in_regexp_as_string.replace(global_escaped_dot_pattern, escaped_dot_replacer);
    };

    return RegExpDotForger;

  })();

  module.exports = RegExpDotForger;

}).call(this);
