// Generated by CoffeeScript 1.4.0

/*
This is tiny data-mining engine

work as mapReduce, but in some different way and use RegExp as path pointer
*/


/*
Timing method decorator
*/


(function() {
  var RegExpDotForger, TinyData, cacheStringify, timeOnDemand, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  timeOnDemand = function(label, methodBody) {
    return function() {
      var __rval__;
      if (this._do_timing_) {
        console.time(label);
      }
      __rval__ = methodBody.apply(this, arguments);
      if (this._do_timing_) {
        console.timeEnd(label);
      }
      return __rval__;
    };
  };

  /*
  Cache mechanism for stringify
  */


  cacheStringify = function(methodBody) {
    return function(in_stringify_filter, in_stubs_list) {
      var stringify_stub_list, stringy_filter, _ref;
      stringy_filter = this._stringification_rule.stringify_filter;
      stringify_stub_list = this._stringification_rule.stubs_list;
      if (!(this._cache_stringifyed_object_ != null) || !_.isEqual(in_stringify_filter, stringy_filter) || !_.isEqual(in_stubs_list, stringify_stub_list)) {
        if (this._do_logging_) {
          console.log('stringify cache miss');
        }
        _ref = [in_stringify_filter, in_stubs_list], stringy_filter = _ref[0], stringify_stub_list = _ref[1];
        return this._cache_stringifyed_object_ = methodBody.call(this, in_stringify_filter, in_stubs_list);
      } else {
        if (this._do_logging_) {
          console.log('stringify cache hit');
        }
        return this._cache_stringifyed_object_;
      }
    };
  };

  _ = (_ref = this._) != null ? _ref : require('lodash');

  RegExpDotForger = require("./regexp_dot_forger");

  TinyData = (function() {

    function TinyData(_original_obj_, _options_) {
      this._original_obj_ = _original_obj_ != null ? _original_obj_ : {};
      this._options_ = _options_ != null ? _options_ : {};
      this.doTransormRegExp = __bind(this.doTransormRegExp, this);

      this._cache_stringifyed_object_ = null;
      this._stringification_rule = {
        stubs_list: [],
        stringify_filter: null,
        apply_on_depth: null
      };
      this._max_text_long_ = 120;
      if ((this._options_.debug != null) && this._options_.debug === true) {
        this._options_.timing = true;
        this._options_.logging = true;
      }
      this._do_timing_ = (this._options_.timing != null) && this._options_.timing === true && ((typeof console !== "undefined" && console !== null ? console.time : void 0) != null) ? true : false;
      this._do_logging_ = (this._options_.logging != null) && this._options_.logging === true && ((typeof console !== "undefined" && console !== null ? console.log : void 0) != null) ? true : false;
      this._dot_ = {
        internal: "\uFE45",
        external: '.'
      };
      this._dot_decorator_settings_ = {
        rakeUp: {
          convert_income_rake_regexp: true,
          convert_before_finalize_function: true,
          convert_out_result: true
        },
        rakeStringify: {
          convert_stringify_filter: true
        }
      };
      this._dot_forger_ = new RegExpDotForger(this.getPathDelimiter('internal'), {
        log: this._do_logging_
      });
    }

    /*
      This is #rakeUp() job - map through all stringifyed object and do some thing,
      then may do some finalization code
    */


    TinyData.prototype.rakeUp = function(in_rake_rule, finalize_function) {
      var finalization_name, finalizer, rake_function, rake_rule, rake_rule_type, raked_object, _ref1;
      _ref1 = this._argParser(in_rake_rule, 'rake_rule'), rake_rule_type = _ref1[0], rake_rule = _ref1[1];
      rake_function = this._buildRakeFunction(rake_rule_type, rake_rule);
      this.rakeStringify(this._stringification_rule.stringify_filter, this._stringification_rule.stubs_list);
      raked_object = this._proceedRake(rake_function);
      if (finalization_name = this._getFinalizationName(finalize_function)) {
        finalizer = this._prepareFinalization(finalization_name, finalize_function);
        return finalizer(raked_object);
      } else {
        return raked_object;
      }
    };

    /*
      This method stringify our original object (materialize full path + add leaf )
      may be used to speed up all by reduce stringification work
    */


    TinyData.prototype.rakeStringify = cacheStringify(timeOnDemand('rakeStringify', function(in_stringify_filter, in_stubs_list) {
      if (in_stubs_list == null) {
        in_stubs_list = [];
      }
      return this._doStringify(in_stringify_filter, in_stubs_list);
    }));

    /*
      This method transform incoming RegExp changes \. (dot) to internal dot-substituter
    */


    TinyData.prototype.doTransormRegExp = function(original_regexp) {
      if (-1 !== original_regexp.source.indexOf(this.getPathDelimiter('internal'))) {
        if (this._do_logging_) {
          console.log("doTransormRegExp: skip converting for |" + original_regexp + "|");
        }
        return original_regexp;
      }
      return this._dot_forger_.doForgeDots(original_regexp);
    };

    /*
      This method may be used for user-defined function
    */


    TinyData.prototype.getPathDelimiter = function(type) {
      switch (type.toUpperCase()) {
        case 'INTERNAL':
          return this._dot_.internal;
        case 'EXTERNAL':
          return this._dot_.external;
        default:
          throw Error("so far don`t know path delimiter, named |" + type + "|, mistype?");
      }
    };

    /*
      That's all, folks!
      Just few public methods :)
    */


    /*
      Try to reduce logic level
    */


    TinyData.prototype._getFinalizationName = function(user_finalize_function) {
      var will_be_finalized;
      will_be_finalized = false;
      if ((user_finalize_function != null) && this._argParser(user_finalize_function, 'finalize_function', 'Function')) {
        if (this._dot_decorator_settings_.rakeUp.convert_before_finalize_function) {
          return 'DECORATE_THEN_FINALAZE';
        } else {
          will_be_finalized = true;
        }
      }
      if (this._dot_decorator_settings_.rakeUp.convert_out_result) {
        if (will_be_finalized) {
          return 'FINALAZE_THEN_DECORATE';
        } else {
          return 'DECORATE';
        }
      }
    };

    /*
      This method build all finalization stuff
      and return simple function
    */


    TinyData.prototype._prepareFinalization = function(finalize_name, user_finalize_function) {
      var result_converter, user_finalizer,
        _this = this;
      result_converter = this._buildResultConvertor();
      user_finalizer = this._buildUserFinalizer(user_finalize_function);
      switch (finalize_name) {
        case 'DECORATE':
          return function(in_obj) {
            return result_converter(in_obj);
          };
        case 'FINALAZE_THEN_DECORATE':
          return function(in_obj) {
            return result_converter(user_finalizer(in_obj));
          };
        case 'DECORATE_THEN_FINALAZE':
          return function(in_obj) {
            return user_finalizer(result_converter(in_obj));
          };
        default:
          throw Error("WTF???!!!");
      }
    };

    /*
      To separate logic of converting
    */


    TinyData.prototype._buildResultConvertor = function() {
      var dot_pattern, dot_symbol,
        _this = this;
      dot_pattern = new RegExp(this.getPathDelimiter('internal'), 'g');
      dot_symbol = this.getPathDelimiter('external');
      return function(in_obj) {
        var idx, item, key, _i, _j, _len, _len1, _ref1, _ref2;
        _ref1 = _.keys(in_obj);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          key = _ref1[_i];
          _ref2 = in_obj[key];
          for (idx = _j = 0, _len1 = _ref2.length; _j < _len1; idx = ++_j) {
            item = _ref2[idx];
            in_obj[key][idx] = in_obj[key][idx].replace(dot_pattern, dot_symbol);
          }
        }
        return in_obj;
      };
    };

    /*
      To separate logic of finalizator
    */


    TinyData.prototype._buildUserFinalizer = function(user_fn) {
      var _this = this;
      return function(in_obj) {
        var emit, finalized_rake_result, key, _i, _len, _ref1;
        finalized_rake_result = {};
        emit = function(key, value) {
          var _ref1;
          if ((key != null) && (value != null)) {
            if ((_ref1 = finalized_rake_result[key]) == null) {
              finalized_rake_result[key] = [];
            }
            return finalized_rake_result[key].push(value);
          }
        };
        _ref1 = _.keys(in_obj);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          key = _ref1[_i];
          user_fn.call(_this, key, in_obj[key], emit);
        }
        return finalized_rake_result;
      };
    };

    /*
      Internal method for wrap timing
    */


    TinyData.prototype._proceedRake = timeOnDemand('proceedRake', function(rake_function) {
      var raked_object;
      return raked_object = rake_function(this._cache_stringifyed_object_);
    });

    /*
      This method return rake function itself, its different for 
      RegExp or Function
    */


    TinyData.prototype._buildRakeFunction = function(rake_rule_type, rake_rule) {
      var _this = this;
      switch (rake_rule_type) {
        case 'REGEXP':
          if (this._dot_decorator_settings_.rakeUp.convert_income_rake_regexp) {
            rake_rule = this.doTransormRegExp(rake_rule);
          }
          return function(in_array) {
            var item, key, matched_obj, rake_result, value, _i, _len, _ref1, _ref2;
            rake_result = {};
            for (_i = 0, _len = in_array.length; _i < _len; _i++) {
              item = in_array[_i];
              if (!(matched_obj = item.match(rake_rule))) {
                continue;
              }
              _ref1 = [matched_obj[2], matched_obj[1].slice(0, -1)], key = _ref1[0], value = _ref1[1];
              if ((_ref2 = rake_result[key]) == null) {
                rake_result[key] = [];
              }
              rake_result[key].push(value);
              null;
            }
            return rake_result;
          };
        case 'FUNCTION':
          return function(in_array) {
            var emit, item, rake_result, _i, _len;
            rake_result = {};
            emit = function(key, value) {
              var _ref1;
              if ((key != null) && (value != null)) {
                if ((_ref1 = rake_result[key]) == null) {
                  rake_result[key] = [];
                }
                return rake_result[key].push(value);
              }
            };
            for (_i = 0, _len = in_array.length; _i < _len; _i++) {
              item = in_array[_i];
              rake_rule.call(_this, item, emit);
            }
            return rake_result;
          };
        default:
          throw Error("WTF???!!");
      }
    };

    /*
      This method parse arg and may ensure its type
    */


    TinyData.prototype._argParser = function(arg, arg_name, strict_type) {
      var arg_type, err_formatter, parsed_arg;
      err_formatter = function(err_string, arg_type) {
        return "" + err_string + "\n|arg_name| = |" + arg_name + "|\n|type| = |" + arg_type + "|\n|arg|   = |" + arg + "|";
      };
      parsed_arg = (function() {
        switch (arg_type = this._getItType(arg)) {
          case 'STRING':
            try {
              return ['REGEXP', RegExp(arg)];
            } catch (error) {
              throw SyntaxError(err_formatter("cant compile this String to RegExp", arg_type));
            }
            break;
          case 'REGEXP':
            return ['REGEXP', arg];
          case 'FUNCTION':
            return ['FUNCTION', arg];
          default:
            throw TypeError(err_formatter("argument must be String, RegExp or Function, but got", arg_type));
        }
      }).call(this);
      if ((strict_type != null) && parsed_arg[0] !== strict_type.toUpperCase()) {
        throw TypeError(err_formatter("argument must be " + strict_type + ", but got", arg_type));
      }
      return parsed_arg;
    };

    /*
      This method stringify object
    */


    TinyData.prototype._doStringify = function(stringify_rule, stubs_list) {
      var dot_sign, filter_body, innner_loop, is_filter_passed, name_matcher, result_array, string_filter, stringify_pattern,
        _this = this;
      result_array = [];
      name_matcher = (stringify_rule != null ? stringify_rule.origin_pattern : void 0) != null ? (stringify_pattern = stringify_rule.origin_pattern, this._dot_decorator_settings_.rakeStringify.convert_stringify_filter ? stringify_pattern = this.doTransormRegExp(stringify_pattern) : void 0, function(matcher_elem_name, matcher_elem_origin) {
        return matcher_elem_name === stringify_rule.element_name && stringify_pattern.test(matcher_elem_origin);
      }) : function(matcher_elem_name) {
        return matcher_elem_name === stringify_rule.element_name;
      };
      filter_body = function(elem_origin, elem_name, elem_depth) {
        if (stringify_rule.apply_on_depth === elem_depth) {
          return name_matcher(elem_name, elem_origin);
        } else {
          return true;
        }
      };
      string_filter = function(full_elem_path, elem_content, elem_depth) {
        var elem_length;
        elem_length = elem_content.length;
        if (!(elem_length > _this._max_text_long_)) {
          return "" + full_elem_path + elem_content;
        } else {
          return "" + full_elem_path + "__LONG_TEXT__|" + elem_length + "|";
        }
      };
      is_filter_passed = stringify_rule != null ? filter_body : function() {
        return true;
      };
      dot_sign = this.getPathDelimiter('internal');
      innner_loop = function(in_obj, prefix, depth) {
        var idx, in_obj_type, key, obj_keys, value, _i, _j, _len, _len1;
        switch (in_obj_type = _this._getItType(in_obj)) {
          case 'HASH':
            obj_keys = _.keys(in_obj);
            if (obj_keys.length) {
              for (_i = 0, _len = obj_keys.length; _i < _len; _i++) {
                key = obj_keys[_i];
                if (is_filter_passed(prefix, key, depth)) {
                  innner_loop(in_obj[key], "" + prefix + key + dot_sign, depth + 1);
                }
              }
            } else {
              innner_loop("__EMPTY__|HASH|", "" + prefix, depth);
            }
            break;
          case 'ARRAY':
            if (in_obj.length) {
              for (idx = _j = 0, _len1 = in_obj.length; _j < _len1; idx = ++_j) {
                value = in_obj[idx];
                if (is_filter_passed(prefix, idx, depth)) {
                  innner_loop(value, "" + prefix + idx + dot_sign, depth + 1);
                }
              }
            } else {
              innner_loop("__EMPTY__|ARRAY|", "" + prefix, depth);
            }
            break;
          case 'PLAIN':
            result_array.push("" + prefix + in_obj);
            break;
          case 'STRING':
            result_array.push(string_filter(prefix, in_obj, depth));
            break;
          case 'DATE':
          case 'REGEXP':
            result_array.push("" + prefix + "__" + in_obj_type + "__|" + in_obj + "|__");
            break;
          default:
            result_array.push("" + prefix + "__" + in_obj_type + "__");
        }
        return null;
      };
      innner_loop(this._original_obj_, '', 0);
      return result_array;
    };

    /*
      This method return type of incoming things
      HASH mean NOT a function or RegExp or something else  - just simple object
    */


    TinyData.prototype._getItType = function(x) {
      if (_.isPlainObject(x)) {
        return 'HASH';
      } else if (_.isArray(x)) {
        return 'ARRAY';
      } else if (_.isString(x)) {
        return 'STRING';
      } else if (_.isNumber(x) || _.isBoolean(x) || _.isNull(x)) {
        return 'PLAIN';
      } else if (_.isFunction(x)) {
        return 'FUNCTION';
      } else if (_.isRegExp(x)) {
        return 'REGEXP';
      } else if (_.isDate(x)) {
        return 'DATE';
      } else if (_.isArguments(x)) {
        return 'ARGUMENTS';
      } else {
        return 'OTHER';
      }
    };

    return TinyData;

  })();

  module.exports = TinyData;

}).call(this);
