// Generated by CoffeeScript 1.4.0

/*
This is tiny data-mining engine

work as mapReduce, but in some different way and use RegExp as path pointer
*/


/*
Timing method decorator
*/


(function() {
  var ArgParserable, Collectable, Finalizer, LogState, MixinSupported, RegExpDotForger, Stringificator, TinyData, getItType, timeOnDemand, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  timeOnDemand = function(label, methodBody) {
    return function() {
      var __rval__;
      if (this._logger_.mustDo('timing')) {
        console.time(label);
      }
      __rval__ = methodBody.apply(this, arguments);
      if (this._logger_.mustDo('timing')) {
        console.timeEnd(label);
      }
      return __rval__;
    };
  };

  _ = (_ref = this._) != null ? _ref : require('lodash');

  RegExpDotForger = require("./lib/" + "regexp_dot_forger");

  Stringificator = require("./lib/stringificator");

  LogState = require("./lib/log_state");

  Finalizer = require("./lib/finalizer");

  getItType = require("./lib/type_detector").getItType;

  MixinSupported = require("./lib/mixin_supported");

  ArgParserable = require("./mixin/arg_parser");

  Collectable = require("./mixin/collector");

  TinyData = (function(_super) {

    __extends(TinyData, _super);

    TinyData.include(ArgParserable);

    TinyData.include(Collectable);

    function TinyData(_original_obj_, _options_) {
      this._original_obj_ = _original_obj_ != null ? _original_obj_ : {};
      this._options_ = _options_ != null ? _options_ : {};
      this.doTransormRegExp = __bind(this.doTransormRegExp, this);

      this._dot_ = {
        internal: "\uFE45",
        external: '.'
      };
      this._convert_income_seek_regexp_ = true;
      this._logger_ = new LogState(this._options_);
      this._dot_forger_ = new RegExpDotForger(this.getPathDelimiter('internal'), {
        log: this._logger_.mustDo('logging')
      });
      this._stringificator_ = new Stringificator(this._original_obj_, this.getPathDelimiter('internal'), this.doTransormRegExp, {
        log: this._logger_.mustDo('logging')
      });
      this._finalizer_ = new Finalizer(this.getPathDelimiter('internal'), this.getPathDelimiter('external'));
    }

    /*
      This method proceed 'seeking' through all stringifyed object and do some thing,
      then may do some finalization code
      Builded for common case of usage, 
      when rule is RegExp and we are want to map matched result in direct order:
      first capture -> key
      second capture -> value
    */


    TinyData.prototype.seekOut = function(in_rake_rule, finalize_function, interp_sequence) {
      if (interp_sequence == null) {
        interp_sequence = {};
      }
      _.defaults(interp_sequence, {
        key: 1,
        value: 2
      });
      if (this._logger_.mustDo('warning') && interp_sequence.key >= interp_sequence.value) {
        console.warn("for reverse interpretation direction it would be better to use #seekOutVerso()\n|key_order|   = |" + interp_sequence.key + "|\n|value_order| = |" + interp_sequence.value + "|");
      }
      return this._seekOutAny(in_rake_rule, finalize_function, interp_sequence);
    };

    /*
      This method proceed 'seeking' through all stringifyed object and do some thing,
      then may do some finalization code
      Builded for common case of usage, 
      when rule is RegExp and we are want to map matched result in reverse order:
      first capture -> value
      second capture -> key
    */


    TinyData.prototype.seekOutVerso = function(in_rake_rule, finalize_function, interp_sequence) {
      if (interp_sequence == null) {
        interp_sequence = {};
      }
      _.defaults(interp_sequence, {
        key: 2,
        value: 1
      });
      if (this._logger_.mustDo('warning') && interp_sequence.value >= interp_sequence.key) {
        console.warn("for direct interpretation direction it would be better to use #seekOut()\n|key_order|   = |" + interp_sequence.key + "|\n|value_order| = |" + interp_sequence.value + "|");
      }
      return this._seekOutAny(in_rake_rule, finalize_function, interp_sequence);
    };

    /*
      This method stringify our original object (materialize full path + add leaf )
      may be used to speed up all by reduce stringification work
    */


    TinyData.prototype.rakeStringify = timeOnDemand('rakeStringify', function(in_stringify_filter, in_stubs_list) {
      if (in_stubs_list == null) {
        in_stubs_list = [];
      }
      return this._stringificator_.stringifyObject(in_stringify_filter, in_stubs_list);
    });

    /*
      This method transform incoming RegExp changes \. (dot) to internal dot-substituter
    */


    TinyData.prototype.doTransormRegExp = function(original_regexp) {
      if (-1 !== original_regexp.source.indexOf(this.getPathDelimiter('internal'))) {
        if (this._logger_.mustDo('logging')) {
          console.log("doTransormRegExp: skip converting for |" + original_regexp + "|");
        }
        return original_regexp;
      }
      return this._dot_forger_.doForgeDots(original_regexp);
    };

    /*
      This method may be used for user-defined function
    */


    TinyData.prototype.getPathDelimiter = function(type) {
      switch (type.toUpperCase()) {
        case 'INTERNAL':
          return this._dot_.internal;
        case 'EXTERNAL':
          return this._dot_.external;
        default:
          throw Error("so far don`t know path delimiter, named |" + type + "|, mistype?");
      }
    };

    /*
      This method return data by path
      It will auto-recognize delimiter, or use force
    */


    TinyData.prototype.getDataByPath = function(path, obj, force_delimiter) {
      var steps;
      if (obj == null) {
        obj = this._original_obj_;
      }
      force_delimiter || (force_delimiter = -1 !== (path != null ? path.indexOf(this.getPathDelimiter('internal')) : void 0) ? this.getPathDelimiter('internal') : this.getPathDelimiter('external'));
      steps = path.split(force_delimiter);
      return _.reduce(steps, (function(obj, i) {
        return obj[i];
      }), obj);
    };

    /*
      That's all, folks!
      Just few public methods :)
    */


    /*
      This is realy seek processor code, one for any directions
    */


    TinyData.prototype._seekOutAny = function(in_seek_rule, finalize_function, interp_sequence) {
      var raked_object, seek_function, seek_rule, seek_rule_type, stringifyed_object, _ref1;
      stringifyed_object = this.rakeStringify();
      _ref1 = this._argParser(in_seek_rule, 'seek_rule'), seek_rule_type = _ref1[0], seek_rule = _ref1[1];
      seek_function = this._buildSeekFunction(seek_rule_type, seek_rule, interp_sequence);
      raked_object = this._proceedSeekingOut(seek_function, stringifyed_object);
      return this._proceedFinalization(finalize_function, raked_object);
    };

    /*
      Internal method for wrap timing
    */


    TinyData.prototype._proceedFinalization = timeOnDemand('finalization', function(finalize_function, raked_object) {
      return this._finalizer_.finalizeResult(finalize_function, raked_object);
    });

    /*
      Internal method for wrap timing
    */


    TinyData.prototype._proceedSeekingOut = timeOnDemand('seekingOut', function(seek_function, stringifyed_object) {
      return seek_function(stringifyed_object);
    });

    /*
      This method return rake function itself, its different for 
      RegExp or Function
    */


    TinyData.prototype._buildSeekFunction = function(rake_rule_type, rake_rule, interp_sequence) {
      var _this = this;
      switch (rake_rule_type) {
        case 'REGEXP':
          if (this._convert_income_seek_regexp_) {
            rake_rule = this.doTransormRegExp(rake_rule);
          }
          return this._buildCollectorLayout(function(item, emit) {
            var matched_obj;
            if (matched_obj = item.match(rake_rule)) {
              emit(matched_obj[interp_sequence.key], matched_obj[interp_sequence.value]);
              return null;
            }
          });
        case 'FUNCTION':
          return this._buildCollectorLayout(rake_rule);
        default:
          throw Error("WTF???!!");
      }
    };

    return TinyData;

  })(MixinSupported);

  module.exports = TinyData;

}).call(this);
