## История бенчмаркинга

### Либы

Переход с undescore на lodash дал примерно 15% прироста


Использование подходящего итератора для массивов и объектов вместо
_.each() так же помогла где-то на 15%

Заменил for of на for in _.keys - довольно полезно

### Фейлы

Пробовал заменить объединение строк на работу с массивами - отстой.
Так как у нас там замыкание, то приходится перед рекурсивным вызовом сначала клонировать объект-контейнер - в результате скорость проседает где-то в 3 раза
по сравнению со строками.

Попытка заменить рекурсию нв итератор провалилась с треском, все резко становится плохо. Рекурсия быстрее всего, не верь на слово интернетным тестам, контекст важен, ага!

### Пришлось

Пришлось переписать часть алгоритма, с вынесением финализации в отдельный шаг, немного потерял в скорости. Но иначе код превращается в мусор.

### Цифры в студии

Приводится для синтетического теста с данными из tinydata-stress_test.coffee

1. speed for full stringification (without excluding and stubbing)

        20480 objects in set : rakeStringify: 510ms,  rake: 542ms  (1060ms)
        40960 objects in set : rakeStringify: 1186ms, rake: 878ms  (2071ms)
        81920 objects in set : rakeStringify: 2153ms, rake: 1395ms (3554ms)

